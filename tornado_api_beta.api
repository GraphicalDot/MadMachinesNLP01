#!/usr/bin/env python
#-*- coding: utf-8 -*-

"""
Author:Kaali
Dated: 17 January, 2015
Day: Saturday
Description: This file has been written for the android developer, This will be used by minimum viable product implementation
            on android 

Comment: None
"""


from __future__ import absolute_import
import base64
import copy
import re
import csv
import codecs
from textblob import TextBlob 
import tornado.escape
import tornado.ioloop
import tornado.web
import tornado.autoreload
from tornado.httpclient import AsyncHTTPClient
from tornado.log import enable_pretty_logging
import hashlib
import subprocess
import shutil
import json
import os
import StringIO
import difflib
from textblob.np_extractors import ConllExtractor 
from bson.json_util import dumps

from compiler.ast import flatten
from topia.termextract import extract
import decimal
import time
from datetime import timedelta
import pymongo
from collections import Counter
from functools import wraps
import itertools
import random
from sklearn.externals import joblib
import numpy
from multiprocessing import Pool
import base64
import requests
from PIL import Image
import inspect
import functools
import tornado.httpserver
from itertools import ifilter
from tornado.web import asynchronous
from tornado.concurrent import run_on_executor
from concurrent.futures import ThreadPoolExecutor
from bson.son import SON
from termcolor import cprint 
from pyfiglet import figlet_format

from Text_Processing.Sentence_Tokenization.Sentence_Tokenization_Classes import SentenceTokenizationOnRegexOnInterjections
from connection import connection, eateries, reviews, eateries_results_collection, reviews_results_collection

from ProductionEnvironmentApi.text_processing_api import PerReview, EachEatery, DoClusters
from ProductionEnvironmentApi.text_processing_db_scripts import MongoScriptsReviews, MongoScriptsDoClusters
from ProductionEnvironmentApi.prod_heuristic_clustering import ProductionHeuristicClustering
from ProductionEnvironmentApi.join_two_clusters import ProductionJoinClusters
from ProductionEnvironmentApi.elasticsearch_db import ElasticSearchScripts
from ProductionEnvironmentApi.query_resolution import QueryResolution

def print_execution(func):
        "This decorator dumps out the arguments passed to a function before calling it"
        argnames = func.func_code.co_varnames[:func.func_code.co_argcount]
        fname = func.func_name
        def wrapper(*args,**kwargs):
                start_time = time.time()
                print "{0} Now {1} have started executing {2}".format(bcolors.OKBLUE, func.func_name, bcolors.RESET)
                result = func(*args, **kwargs)
                print "{0} Total time taken by {1} for execution is --<<{2}>>--{3}\n".format(bcolors.OKGREEN, func.func_name,
                                (time.time() - start_time), bcolors.RESET)
                return result
        return wrapper




def cors(f):
        @functools.wraps(f) # to preserve name, docstring, etc.
        def wrapper(self, *args, **kwargs): # **kwargs for compability with functions that use them
                self.set_header("Access-Control-Allow-Origin",  "*")
                self.set_header("Access-Control-Allow-Headers", "content-type, accept")
                self.set_header("Access-Control-Max-Age", 60)
                return f(self, *args, **kwargs)
        return wrapper
                                                        





class UsersFeedback(tornado.web.RequestHandler):
	@cors
	@tornado.gen.coroutine
	@asynchronous
        def post(self):
                
                feedback = self.get_argument("feedback")
                name = self.get_argument("name")
                telephone = self.get_argument("telephone")
                email = self.get_argument("email")
                print feedback
                users_feedback.insert({"feedback": feedback, "name": name, "telephone": telephone, "email": email, "timestamp": time.time()})
                self.write({"success": True,
			"error": False,
			})
                self.finish()
                return

class UsersDetails(tornado.web.RequestHandler):
	@cors
	@tornado.gen.coroutine
	@asynchronous
        def post(self):
                fb_id = self.get_argument("id")
                name = self.get_argument("name")
                email = self.get_argument("email")
                picture = self.get_argument("picture")
                print fb_id, name, email, picture
                print users_details
                print users_details.update({"fb_id": fb_id}, {"$set": { "name": name, "email": email, "picture": picture}}, upsert=True)
                self.write({"success": True,
			"error": False,
			})
                self.finish()
                return



class GetTrending(tornado.web.RequestHandler):
        @cors
	@print_execution
	@tornado.gen.coroutine
        def post(self):
                """
                """
                        
                latitude = float(self.get_argument("latitude"))
                longitude = float(self.get_argument("longitude"))
                print type(longitude)
                result = ElasticSearchScripts.get_trending(latitude, longitude)
 
                self.write({"success": True,
			        "error": False,
			        "result": result,
			        })
                self.finish()
                return 


class NearestEateries(tornado.web.RequestHandler):
	@cors
	@print_execution
        #@tornado.gen.coroutine
        @asynchronous
        def post(self):
                """
                Accoriding to the latitude, longitude given to it gives out the 10 restaurants nearby
                """
                
                latitude =  float(self.get_argument("lat"))
                longitude =  float(self.get_argument("long")) 
                
                if not range:
                        range = 5
                else:
                        range = int(range)
                


                projection={"eatery_id": True, "eatery_name": True, "eatery_address": True, "eatery_coordinates": True, "eatery_total_reviews": True, "_id": False}
                #result = eateries.find({"eatery_coordinates": {"$near": [lat, long]}}, projection).sort("eatery_total_reviews", -1).limit(10)
                result = eateries.find({"eatery_coordinates" : SON([("$near", { "$geometry" : SON([("type", "Point"), ("coordinates", [lat, long]), \
                        ("$maxDistance", range)])})])}, projection).limit(10)

                eateries_results_collection.find({"location": {"$near": [latitude, longitude]}}).limit(10):
                
                __result  = list(result)
                print __result
                self.write({"success": True,
			"error": False,
                        "result": __result,
			})
                self.finish()
                
class GetEatery(tornado.web.RequestHandler):
	@cors
	@print_execution
        #@tornado.gen.coroutine
        @asynchronous
        def post(self):
                """
                NUmber of dishes to be returne is 14 , and the overfood is to be included also


                keys of each dict in food key of result are
                [u'name', 'series', 'cumulative', u'negative', 'supernegative', u'neutral', u'timeline', 'superpositive', 
                'totalsentiments', u'similar', u'positive', 'categories']

                """
                number_of_dishes = 20
                eatery_id =  self.get_argument("eatery_id")

                type_of_data =  self.get_argument("type_of_data")
               
                
                result = eateries_results_collection.find_one({"eatery_id": eatery_id})
                if not result:
                        self.write({"success": False,
			        "error": True,
                                "messege": "eatery id not present in the database" ,
	        		})
                        self.finish()
                        return  
                
                dishes = sorted(result["food"]["dishes"], key=lambda x: x.get("total_sentiments"), reverse=True)[0: number_of_dishes]
                overall_food = result["food"]["overall-food"]
                ambience = result["ambience"]
                cost = result["cost"]
                service = result["service"]


                if type_of_data == "highchart":
                            result = {
                                        "food": convert_for(dishes),
                                        "ambience": convert_for(ambience), 
                                        "cost": convert_for(cost), 
                                        "service": convert_for(service), 
                                        "eatery_address": result["eatery_address"],
                                    }

                else:
                        [dish.pop("timeline") for dish in dishes]    
                        [dish.pop("similar") for dish in dishes]    
                        [ambience[key].pop("timeline") for key in ambience.keys()]    
                        [cost[key].pop("timeline") for key in cost.keys()]    
                        [service[key].pop("timeline") for key in service.keys()]    
                        result = {
                                        "food": dishes,
                                        "ambience": ambience, 
                                        "cost": cost, 
                                        "service": service, 
                                        "eatery_address": result["eatery_address"],
                                    }
                        


                cprint(figlet_format('Finished executing %s'%self.__class__.__name__, font='mini'), attrs=['bold'])
                self.write({"success": True,
			"error": False,
                        "result": result})
                self.finish()



class TextSearch(tornado.web.RequestHandler):
        @cors
	@print_execution
	@tornado.gen.coroutine
        def post(self):
                """

                """
                text = self.get_argument("text")
                __type = self.get_argument("type")


                if __type == "dish":
                        ##search in ES for dish name 


                elif __type == "cuisine":
                        ##gives out the restarant for cuisine name


                else:
                        self.write({"success": False,
			        "error": True,
			        "messege": "Maaf kijiyega, Yeh na ho paayega",
			        })
                        self.finish()
                return 



class Suggestions(tornado.web.RequestHandler):
        @cors
	@print_execution
	@tornado.gen.coroutine
        def get(self):
                """
                """
                        
                query = self.get_argument("query")
                
                dish_suggestions = list(set(ElasticSearchScripts.dish_suggestions(query)))
                cuisine_suggestions =  ElasticSearchScripts.cuisines_suggestions(query)
                eatery_suggestions = ElasticSearchScripts.eatery_suggestions(query)
                #address_suggestion = ElasticSearchScripts.address_suggestions(query)
                
                result = list(set(["{0}".format(element["name"]) for element in result]))
                print result 

                self.write({"success": True,
			        "error": False,
			        "options": result,
			        })
                self.finish()
                return 


class GetEatery(tornado.web.RequestHandler):
        @cors
	@print_execution
	@tornado.gen.coroutine
        def post(self):
                """
                """
                        
                number_of_dishes = 20
                eatery_name =  self.get_argument("eatery_name")
                type_of_data =  self.get_argument("type_of_data")
                result = eateries_results_collection.find_one({"eatery_name": eatery_name})
                if not result:
                        """
                        If the eatery name couldnt found in the mongodb for the popular matches
                        Then we are going to check for demarau levenshetin algorithm for string similarity
                        """



                    
                    
                    
                        return 
                
                dishes = sorted(result["food"]["dishes"], key=lambda x: x.get("total_sentiments"), reverse=True)[0: number_of_dishes]
                overall_food = result["food"]["overall-food"]
                ambience = result["ambience"]
                cost = result["cost"]
                service = result["service"]


                if type_of_data == "highchart":
                            result = {
                                        "food": convert_for(dishes),
                                        "ambience": convert_for(ambience), 
                                        "cost": convert_for(cost), 
                                        "service": convert_for(service), 
                                        "eatery_address": result["eatery_address"],
                                    }

                else:
                        [dish.pop("timeline") for dish in dishes]    
                        [dish.pop("similar") for dish in dishes]    
                        [ambience[key].pop("timeline") for key in ambience.keys()]    
                        [cost[key].pop("timeline") for key in cost.keys()]    
                        [service[key].pop("timeline") for key in service.keys()]    
                        result = {
                                        "food": dishes,
                                        "ambience": ambience, 
                                        "cost": cost, 
                                        "service": service, 
                                        "eatery_address": result["eatery_address"],
                                    }
                        

                cprint(figlet_format('Finished executing %s'%self.__class__.__name__, font='mini'), attrs=['bold'])
                self.write({"success": True,
			"error": False,
                        "result": result})
                self.finish()

                return 

class GetEaterySuggestions(tornado.web.RequestHandler):
        @cors
	@print_execution
	@tornado.gen.coroutine
        def get(self):
                """
                """
                        
                dish_name = self.get_argument("query")
                
                result = ElasticSearchScripts.eatery_suggestions(dish_name)
                result = list(set(["{0}".format(element["eatery_name"]) for element in result]))
                print result
                self.write({"success": True,
			        "error": False,
			        "options": result,
			        })
                self.finish()
                return 

def main():
        http_server = tornado.httpserver.HTTPServer(Application())
        tornado.autoreload.start()
        http_server.listen("8000")
        enable_pretty_logging()
        tornado.ioloop.IOLoop.current().start()


class Application(tornado.web.Application):
        def __init__(self):
                handlers = [
                    (r"/suggestions", Suggestions),
                    (r"/get_trending", GetTrending),
                    
                    
                    
                    
                    
                    
                    
                    
                    (r"/limited_eateries_list", LimitedEateriesList),
                    (r"/get_word_cloud", GetWordCloud),
                    (r"/resolve_query", Query),
                    (r"/get_trending", GetTrending),
                    (r"/nearest_eateries", NearestEateries),
                    (r"/eateries_on_character", EateriesOnCharacter),
                    (r"/users_details", UsersDetails),
                    (r"/users_feedback", UsersFeedback),
                    (r"/get_dishes", GetDishes),
                    (r"/get_eatery", GetEatery),
                    (r"/get_dish_suggestions", GetDishSuggestions),
                    (r"/get_eatery_suggestions", GetEaterySuggestions),
                    (r"/sentence_tokenization", SentenceTokenization),
                    (r"/upload_sentence", UploadSentence),
                
                    (r"/eatery_details", EateryDetails),]
                settings = dict(cookie_secret="__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",)
                tornado.web.Application.__init__(self, handlers, **settings)
                self.executor = ThreadPoolExecutor(max_workers=60)



if __name__ == '__main__':
    cprint(figlet_format('Server Reloaded', font='big'), attrs=['bold'])
    main()
